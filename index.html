<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quick Play Hoop Simulator v3 (Collision)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            background-color: #1f2937;
            display: flex;
            flex-direction: column;
        }
        #hoop-container {
            flex-grow: 1;
            position: relative;
        }
        canvas {
            display: block;
        }
        .info-panel {
            background-color: rgba(255, 255, 255, 0.95);
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            max-width: 400px;
            pointer-events: auto;
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        .controls-bar {
            background-color: #ffffff;
            padding: 10px 20px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            width: 100%;
            display: flex;
            justify-content: space-around;
            align-items: center;
            pointer-events: auto;
            z-index: 10;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="hoop-container">
        <div id="message"></div>
        <div class="info-panel hidden md:block">
            <h1 class="text-xl font-bold text-gray-800 mb-3">Quick Play v3: Rim Collision Added!</h1>
            <ul class="list-disc ml-4 text-sm text-gray-700">
                <li>**Click & Drag / Scroll:** Orbit/Zoom.</li>
                <li>**LAUNCH:** Shoots the ball with perfect power for the set angle/distance.</li>
                <li>**New!** The ball now **bounces** off the rim and backboard.</li>
            </ul>
        </div>
    </div>

    <div class="controls-bar">
        <div class="control-group">
            <label for="angle" class="text-xs font-semibold text-gray-600 mb-1">Launch Angle ($\theta$):</label>
            <input type="range" id="angle" min="30" max="80" value="45" step="1" class="w-32">
            <span id="angleValue" class="text-sm font-mono text-indigo-600">45°</span>
        </div>
        <div class="control-group">
            <button id="launchButton" class="px-6 py-2 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-700 transition duration-150">
                LAUNCH SHOT!
            </button>
        </div>
        <div class="control-group">
            <label for="distance" class="text-xs font-semibold text-gray-600 mb-1">Shot Distance (m):</label>
            <input type="range" id="distance" min="5" max="15" value="7.24" step="0.1" class="w-32">
            <span id="distanceValue" class="text-sm font-mono text-pink-600">7.24 m</span>
        </div>
    </div>

    <script>
        // --- Firebase Globals (Required but not used) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? initialAuthToken : '';
        // ------------------------------------------------

        // Physics Constants
        const G = 9.81; // Gravity (m/s^2)
        const COEFFICIENT_OF_RESTITUTION = 0.5; // How bouncy the rim is (0.0 = dead, 1.0 = perfect bounce)
        const BACKBOARD_RESTITUTION = 0.8; // Backboard is bouncier than the rim
        const HOOP_HEIGHT = 3.05; // 10ft
        const LAUNCH_HEIGHT = 1.8;
        const ballRadius = 0.12;
        const TIME_STEP = 1/60; // 60 FPS update rate

        // THREE.js Globals
        let scene, camera, renderer, courtGroup, hoopGroup;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let shotStartTime = 0;
        let ball = null;
        let isShooting = false;
        let currentV0 = new THREE.Vector3(); // Now a vector for collision response
        let currentPosition = new THREE.Vector3();
        let shotDistance = 7.24;

        // Hoops Specs (for collision detection)
        const RIM_RADIUS = 0.457 / 2; // 18 inches
        const RIM_TUBE_RADIUS = 0.03;
        const RIM_CENTER_Y = HOOP_HEIGHT;
        const RIM_CENTER_Z = -1.0 - 0.15; // Hoop Z offset relative to hoopGroup (which is positioned by shotDistance)
        const BACKBOARD_Z_FACE = -1.0; // Backboard Z face relative to hoopGroup

        // DOM Elements
        const angleInput = document.getElementById('angle');
        const distanceInput = document.getElementById('distance');
        const launchButton = document.getElementById('launchButton');
        const angleValueSpan = document.getElementById('angleValue');
        const distanceValueSpan = document.getElementById('distanceValue');
        const messageDisplay = document.getElementById('message');

        window.onload = function () {
            init();
            animate();
            addEventListeners();
            updateUI();
        }

        // --- INIT AND MODELING FUNCTIONS (same as v2) ---
        function init() {
            const container = document.getElementById('hoop-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x374151);

            camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
            camera.position.set(0, 3, 15);
            camera.lookAt(0, HOOP_HEIGHT, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);
            
            courtGroup = new THREE.Group();
            hoopGroup = new THREE.Group();

            createCourt();
            createHoop();
            
            hoopGroup.position.set(0, 0, -parseFloat(distanceInput.value)); 
            
            scene.add(courtGroup);
            scene.add(hoopGroup);

            createBall();
            window.addEventListener('resize', onWindowResize, false);
        }

        function createCourt() {
            const courtGeometry = new THREE.PlaneGeometry(30, 40);
            const courtMaterial = new THREE.MeshLambertMaterial({ color: 0x22c55e }); 
            const court = new THREE.Mesh(courtGeometry, courtMaterial);
            court.rotation.x = -Math.PI / 2;
            court.position.y = -0.1;
            courtGroup.add(court);
        }
        
        // Detailed Hoop Model Creation (omitted details for brevity, uses same constants as v2)
        function createHoop() {
            const BACKBOARD_WIDTH = 1.83, BACKBOARD_HEIGHT = 1.07, BACKBOARD_THICKNESS = 0.03;
            const PADDING_HEIGHT = 0.2, NET_LENGTH = 0.45;
            
            // Backboard (Clear/Glass)
            const backboardGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, BACKBOARD_HEIGHT, BACKBOARD_THICKNESS);
            const backboardMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, transparent: true, opacity: 0.8, shininess: 150});
            const backboard = new THREE.Mesh(backboardGeometry, backboardMaterial);
            backboard.position.set(0, RIM_CENTER_Y + (BACKBOARD_HEIGHT / 2) - 0.3, BACKBOARD_Z_FACE);
            hoopGroup.add(backboard);

            // Backboard Padding (Thick Red Padding)
            const paddingGeometry = new THREE.BoxGeometry(BACKBOARD_WIDTH, PADDING_HEIGHT, BACKBOARD_THICKNESS * 2);
            const paddingMaterial = new THREE.MeshLambertMaterial({ color: 0xcc0000 });
            const padding = new THREE.Mesh(paddingGeometry, paddingMaterial);
            padding.position.set(backboard.position.x, backboard.position.y - (BACKBOARD_HEIGHT / 2) + (PADDING_HEIGHT / 2), backboard.position.z);
            hoopGroup.add(padding);

            // Rim (Orange/Red Metal)
            const rimGeometry = new THREE.TorusGeometry(RIM_RADIUS, RIM_TUBE_RADIUS, 12, 60);
            const rimMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500, shininess: 80 });
            const rim = new THREE.Mesh(rimGeometry, rimMaterial);
            rim.rotation.x = Math.PI / 2;
            rim.position.set(0, RIM_CENTER_Y, RIM_CENTER_Z + 1.0); // Z position adjusted
            hoopGroup.add(rim);

            // Net (Tapered Cone/Cylinder)
            const netGeometry = new THREE.CylinderGeometry(RIM_RADIUS, RIM_RADIUS * 0.5, NET_LENGTH, 60, 1, true); 
            const netMaterial = new THREE.MeshPhongMaterial({color: 0xffffff, transparent: true, opacity: 0.8, wireframe: true, side: THREE.DoubleSide});
            const net = new THREE.Mesh(netGeometry, netMaterial);
            net.position.set(rim.position.x, rim.position.y - NET_LENGTH / 2, rim.position.z);
            hoopGroup.add(net);
        }

        function createBall() {
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshLambertMaterial({ color: 0xff8c00 });
            ball = new THREE.Mesh(ballGeometry, ballMaterial);
            ball.position.set(0, LAUNCH_HEIGHT, parseFloat(distanceInput.value)); 
            scene.add(ball);
        }

        // --- CORE PHYSICS CALCULATION ---
        function calculateRequiredVelocity(xf, yf, theta, g) {
            const cosTheta = Math.cos(theta);
            const tanTheta = Math.tan(theta);
            yf = yf - LAUNCH_HEIGHT;
            
            const denominator = (xf * tanTheta - yf);
            if (denominator <= 0) return 30; 

            const numerator = g * xf * xf;
            const requiredV2 = numerator / (2 * cosTheta * cosTheta * denominator);

            return Math.sqrt(requiredV2);
        }
        
        function getRequiredVelocityVector(v0_scalar, theta) {
            const v0x = 0; // No horizontal movement perpendicular to the shot
            const v0y = v0_scalar * Math.sin(theta);
            const v0z = -v0_scalar * Math.cos(theta); // Shot travels down the -Z axis
            return new THREE.Vector3(v0x, v0y, v0z);
        }

        // --- GAME LOGIC ---
        function shootBall() {
            if (isShooting) return;
            messageDisplay.style.opacity = 0;

            const angleDegrees = parseFloat(angleInput.value);
            shotDistance = parseFloat(distanceInput.value);
            const angleRadians = angleDegrees * (Math.PI / 180);
            
            const xf = shotDistance; 
            const yf = HOOP_HEIGHT;

            const v0_scalar = calculateRequiredVelocity(xf, yf, angleRadians, G);

            // Set initial position and velocity vector
            currentPosition.set(0, LAUNCH_HEIGHT, shotDistance);
            currentV0 = getRequiredVelocityVector(v0_scalar, angleRadians);
            
            ball.position.copy(currentPosition);
            
            shotStartTime = performance.now();
            isShooting = true;
        }

        function displayMessage(text, color) {
            messageDisplay.textContent = text;
            messageDisplay.style.color = color;
            messageDisplay.style.opacity = 1;
            setTimeout(() => { messageDisplay.style.opacity = 0; }, 2000);
        }

        function checkCollisionAndBounce(prevPos, nextPos, velocity) {
            const hoopGroupAbsoluteZ = -parseFloat(distanceInput.value);
            const rimAbsoluteY = RIM_CENTER_Y;
            const rimAbsoluteZ = hoopGroupAbsoluteZ + RIM_CENTER_Z + 1.0; 
            const backboardAbsoluteZ = hoopGroupAbsoluteZ + BACKBOARD_Z_FACE;
            
            // Backboard Collision Check (Simplified plane collision)
            // Check if ball is near the backboard and moving in the +Z direction (towards the board)
            if (prevPos.z < backboardAbsoluteZ && nextPos.z >= backboardAbsoluteZ && Math.abs(prevPos.x) < 1.0) {
                // Ball hits the backboard (flat surface)
                if (nextPos.y < rimAbsoluteY + RIM_RADIUS + ballRadius) { // Only bounce if ball is below rim height + safety margin
                    velocity.z *= -BACKBOARD_RESTITUTION; // Reverse and dampen Z velocity
                    nextPos.z = backboardAbsoluteZ - ballRadius; // Correct position to prevent sinking
                    return true;
                }
            }
            
            // Rim Collision Check (Simplified Torus/Circle collision)
            const rimCenter = new THREE.Vector3(0, rimAbsoluteY, rimAbsoluteZ);
            const diff = nextPos.clone().sub(rimCenter);
            
            // Project the difference vector onto the XZ plane (we only care about distance from center)
            const dist2D = Math.sqrt(diff.x * diff.x + diff.z * diff.z); 
            
            // Check if horizontal distance is close to the rim's radius
            const horizontalCollisionDist = RIM_RADIUS + RIM_TUBE_RADIUS + ballRadius;
            
            if (dist2D < horizontalCollisionDist) {
                // If it's near the rim's horizontal area
                const tubeDist = Math.abs(dist2D - RIM_RADIUS); // Distance from the central ring of the rim
                const verticalDist = Math.abs(diff.y);
                
                // If the ball is within the rim tube's collision zone (simplified)
                if (tubeDist < RIM_TUBE_RADIUS + ballRadius && verticalDist < RIM_TUBE_RADIUS + ballRadius) {
                    
                    // Simple radial bounce (reflect velocity away from the rim's central point)
                    const normal = new THREE.Vector3(diff.x, diff.y, diff.z);
                    normal.normalize();

                    // The 'perfect swish' zone check
                    if (dist2D < RIM_RADIUS && nextPos.y < rimAbsoluteY) {
                         // Ball is inside the rim and below the height: assume swish/score
                        return false; 
                    }

                    // Calculate reflected velocity
                    const dot = velocity.dot(normal);
                    velocity.sub(normal.multiplyScalar(2 * dot * COEFFICIENT_OF_RESTITUTION));
                    
                    // Set a minimum outbound speed
                    if (velocity.length() < 5) velocity.multiplyScalar(5 / velocity.length());

                    nextPos.add(normal.multiplyScalar(0.01)); // Push ball out slightly
                    
                    return true;
                }
            }
            return false;
        }

        function updateBallPosition() {
            if (!isShooting) return;

            const timeNow = performance.now();
            const deltaTime = TIME_STEP; // Fixed time step for stability

            // Use elapsed time from shot start for integration
            let totalTimeElapsed = (timeNow - shotStartTime) / 1000;
            
            let prevPos = currentPosition.clone();
            
            // Update velocity (Gravity: constant acceleration in the negative Y direction)
            currentV0.y -= G * deltaTime; 
            
            // Update position (Position = Old Position + Velocity * Time)
            currentPosition.add(currentV0.clone().multiplyScalar(deltaTime));

            // Collision Detection
            const didCollide = checkCollisionAndBounce(prevPos, currentPosition, currentV0);
            
            // After collision, reset position/velocity based on results
            ball.position.copy(currentPosition);

            // Simple backspin for visual realism
            ball.rotation.x += currentV0.z * 0.05;

            // Stop conditions
            if (currentPosition.y < 0.1) {
                // Ground hit
                isShooting = false;
                displayMessage("MISS (Airball/Ground)", "#f00");
                // Reset ball
                setTimeout(() => {
                    ball.position.set(0, LAUNCH_HEIGHT, shotDistance); 
                }, 1000);
            }
            
            // Success condition (Ball goes below the rim height within the rim's horizontal space)
            const hoopGroupAbsoluteZ = -parseFloat(distanceInput.value);
            const rimAbsoluteZ = hoopGroupAbsoluteZ + RIM_CENTER_Z + 1.0;
            const diffZ = currentPosition.z - rimAbsoluteZ;
            
            // If ball passes the rim Z-plane and is within the rim's X-radius, and its Y is below the rim
            if (diffZ > 0.05 && Math.abs(currentPosition.x) < RIM_RADIUS && currentPosition.y < RIM_CENTER_Y - ballRadius * 2) {
                isShooting = false;
                displayMessage("SWISH!", "#00ff00");
                setTimeout(() => {
                    ball.position.set(0, LAUNCH_HEIGHT, shotDistance); 
                }, 2000);
            }
        }


        // --- UTILITIES AND ANIMATE LOOP ---
        let lastUpdateTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);

            // Use a fixed timestep for physics updates for more stable collision detection
            const timeNow = performance.now();
            let delta = (timeNow - lastUpdateTime) / 1000;

            // Multiple steps for complex physics if delta is large (not fully implemented here but good practice)
            while (delta >= TIME_STEP) {
                updateBallPosition();
                delta -= TIME_STEP;
            }

            lastUpdateTime = timeNow - delta * 1000;
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('hoop-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function updateUI() {
            angleValueSpan.textContent = `${angleInput.value}°`;
            distanceValueSpan.textContent = `${distanceInput.value} m`;
            
            // Reposition the hoop based on distance input
            hoopGroup.position.z = -parseFloat(distanceInput.value);
            shotDistance = parseFloat(distanceInput.value);
            
            // Reposition ball to the new distance
            if (!isShooting) {
                ball.position.set(0, LAUNCH_HEIGHT, shotDistance); 
            }
        }
        
        function addEventListeners() {
            const container = document.getElementById('hoop-container');
            
            angleInput.addEventListener('input', updateUI);
            distanceInput.addEventListener('input', updateUI);
            launchButton.addEventListener('click', shootBall);

            // ... (Orbit and Zoom Controls remain the same) ...
            const handlePointerDown = (clientX, clientY) => {
                isDragging = true;
                previousMousePosition.x = clientX;
                previousMousePosition.y = clientY;
            };

            const handlePointerMove = (clientX, clientY) => {
                if (!isDragging) return;

                const deltaX = clientX - previousMousePosition.x;
                const deltaY = clientY - previousMousePosition.y;
                
                courtGroup.rotation.y += deltaX * 0.005;

                camera.position.y -= deltaY * 0.05;
                camera.lookAt(0, HOOP_HEIGHT, 0); 
                
                previousMousePosition.x = clientX;
                previousMousePosition.y = clientY;
            };

            const handlePointerUp = () => {
                isDragging = false;
            };

            container.addEventListener('mousedown', (e) => {
                const infoPanel = document.querySelector('.info-panel');
                if (infoPanel && infoPanel.contains(e.target)) return;
                handlePointerDown(e.clientX, e.clientY);
            });
            container.addEventListener('mouseup', handlePointerUp);
            container.addEventListener('mousemove', (e) => handlePointerMove(e.clientX, e.clientY));

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.position.z += e.deltaY * 0.01;
                camera.position.z = Math.max(5, Math.min(30, camera.position.z));
            });

            container.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    handlePointerDown(e.touches[0].clientX, e.touches[0].clientY);
                }
            }, { passive: false });

            container.addEventListener('touchend', handlePointerUp, { passive: false });

            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDragging || e.touches.length !== 1) return;
                handlePointerMove(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });
        }
    </script>
</body>
</html>
```eof

This new file, `quick_play_hoop_v3.html`, integrates the Rim Collision logic.

Give it a shot! Try lowering the angle to get a flatter, faster trajectory. The ball will bounce off the rim or backboard instead of simply flying through the air. You should now see a much more interesting shot result!

To continue making the game even better, the next and final physics stage is to implement **Net Physics** (the cloth simulation for a soft "swish"). Would you like to add that next?
