<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Basketball Hoopz</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0d0d0d; font-family: 'Arial', sans-serif; }
        canvas { display: block; }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            text-align: center;
            z-index: 10;
        }
        #controls {
            margin-top: 10px;
            font-size: 1.1em;
            color: #4CAF50; /* Green highlight for controls */
        }
        .control-key {
            background: #222;
            padding: 2px 6px;
            border-radius: 3px;
            margin: 0 4px;
            border: 1px solid #333;
        }
    </style>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Cannon.js Physics Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
</head>
<body>
    <div id="overlay">
        <h1>Quick Play Mode</h1>
        <p>Use the controls below to dribble and shoot!</p>
        <div id="controls">
            Move: <span class="control-key">W</span> (Forward) <span class="control-key">A</span> (Left Dribble) <span class="control-key">S</span> (Backward) <span class="control-key">D</span> (Right Dribble)<br>
            Shoot: <span class="control-key">E</span>
        </div>
    </div>

    <script>
        // --- SCENE SETUP (THREE.JS) ---
        let scene, camera, renderer;
        let world; // Cannon.js world
        let ballMesh, ballBody;
        let playerVelocity = new THREE.Vector3();
        let isShooting = false;
        let hoopPosition = new THREE.Vector3(0, 3, -15);
        let shootForce = 15; // The power of the E key shot

        // Player/Camera controls
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;

        // Player movement speed
        const speed = 0.15;
        const dribbleOffset = 0.8;
        const playerHeight = 1.8;
        const ballRadius = 0.25;

        // --- INITIALIZATION ---
        function init() {
            // 1. Scene and Renderer
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x111111, 0, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 2. Camera Setup (The Player)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, playerHeight, 5); // Start on the court
            camera.lookAt(hoopPosition);

            // 3. Lighting
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // 4. Physics World (CANNON.JS)
            world = new CANNON.World();
            world.gravity.set(0, -9.82, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            // 5. Create Court and Hoop
            createCourt();
            createHoop();
            
            // 6. Create Basketball
            createBall();

            // 7. Event Listeners
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            animate();
        }

        // --- OBJECT CREATION ---

        function createCourt() {
            // THREE.js Mesh (Visual)
            const courtGeometry = new THREE.PlaneGeometry(30, 60);
            const courtMaterial = new THREE.MeshStandardMaterial({ color: 0xcc8855, side: THREE.DoubleSide });
            const courtMesh = new THREE.Mesh(courtGeometry, courtMaterial);
            courtMesh.rotation.x = Math.PI / 2;
            courtMesh.receiveShadow = true;
            scene.add(courtMesh);

            // CANNON.js Body (Physics)
            const courtShape = new CANNON.Plane();
            const courtBody = new CANNON.Body({ mass: 0 }); // mass = 0 makes it static
            courtBody.addShape(courtShape);
            courtBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be flat
            world.addBody(courtBody);
        }

        function createHoop() {
            // Backboard (Visual)
            const backboardGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
            const backboardMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
            const backboardMesh = new THREE.Mesh(backboardGeo, backboardMat);
            backboardMesh.position.set(hoopPosition.x, hoopPosition.y + 0.5, hoopPosition.z);
            backboardMesh.castShadow = true;
            scene.add(backboardMesh);

            // Pole (Visual)
            const poleGeo = new THREE.CylinderGeometry(0.1, 0.1, 5, 12);
            const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
            const poleMesh = new THREE.Mesh(poleGeo, poleMat);
            poleMesh.position.set(hoopPosition.x, hoopPosition.y - 2.5 + 0.5, hoopPosition.z + 0.5);
            poleMesh.castShadow = true;
            scene.add(poleMesh);

            // Rim (Visual - simplified torus)
            const rimGeo = new THREE.TorusGeometry(0.4, 0.05, 8, 32);
            const rimMat = new THREE.MeshStandardMaterial({ color: 0xff4400 });
            const rimMesh = new THREE.Mesh(rimGeo, rimMat);
            rimMesh.rotation.x = Math.PI / 2;
            rimMesh.position.set(hoopPosition.x, hoopPosition.y, hoopPosition.z + 0.15);
            rimMesh.castShadow = true;
            scene.add(rimMesh);

            // Rim (Physics - Cannon.js)
            // Use a few small boxes/cylinders for a simplified rim collider to allow shooting through
            const rimShape = new CANNON.Cylinder(0.4, 0.4, 0.1, 16);
            const rimBody = new CANNON.Body({ mass: 0, material: new CANNON.Material('rimMat') });
            rimBody.addShape(rimShape);
            rimBody.position.set(hoopPosition.x, hoopPosition.y, hoopPosition.z + 0.15);
            world.addBody(rimBody);
        }

        function createBall() {
            // THREE.js Mesh (Visual)
            const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xff8800, flatShading: true });
            ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
            ballMesh.castShadow = true;
            scene.add(ballMesh);

            // CANNON.js Body (Physics)
            const ballShape = new CANNON.Sphere(ballRadius);
            ballBody = new CANNON.Body({ mass: 1, shape: ballShape, material: new CANNON.Material('ballMat') });
            ballBody.position.set(camera.position.x, camera.position.y - 0.5, camera.position.z);
            ballBody.linearDamping = 0.01;
            ballBody.angularDamping = 0.01;
            ballBody.isKinematic = true; // Start in tethered (dribbling) mode
            world.addBody(ballBody);
        }

        // --- INPUT HANDLING ---

        function onKeyDown(event) {
            switch (event.keyCode) {
                case 87: // W
                    moveForward = true;
                    break;
                case 83: // S
                    moveBackward = true;
                    break;
                case 65: // A
                    moveLeft = true;
                    break;
                case 68: // D
                    moveRight = true;
                    break;
                case 69: // E (SHOOT)
                    if (!isShooting) {
                        shoot();
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.keyCode) {
                case 87: // W
                    moveForward = false;
                    break;
                case 83: // S
                    moveBackward = false;
                    break;
                case 65: // A
                    moveLeft = false;
                    break;
                case 68: // D
                    moveRight = false;
                    break;
            }
        }

        // --- GAME LOGIC ---

        function shoot() {
            isShooting = true;
            ballBody.isKinematic = false; // Release the ball from the player
            
            // Calculate direction vector from ball to hoop
            let targetVector = new THREE.Vector3(hoopPosition.x, hoopPosition.y, hoopPosition.z);
            let shotDirection = targetVector.clone().sub(ballMesh.position).normalize();

            // Apply an upward boost for arc
            shotDirection.y += 1.0; 
            shotDirection.normalize();

            // Set the ball's velocity
            ballBody.velocity.set(
                shotDirection.x * shootForce,
                shotDirection.y * shootForce,
                shotDirection.z * shootForce
            );

            // After a few seconds, if the ball hasn't been picked up, allow it to be picked up
            setTimeout(() => {
                if(ballBody.position.y < -1) { // If it fell off the court, reset
                    resetBall();
                } else if (isShooting) {
                    // Simple check: if the ball hits the ground, reset the shooting state 
                    // and let the player 'run over' it to pick it up (done in update loop)
                    isShooting = false; 
                }
            }, 5000);
        }

        function resetBall() {
            isShooting = false;
            ballBody.isKinematic = true;
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. Physics Step
            world.step(1/60); // Update physics 60 times per second

            // 2. Player Movement
            let currentSpeed = speed;

            // Reset player velocity for smooth movement
            playerVelocity.set(0, 0, 0);

            let offsetVector = new THREE.Vector3(0, 0, 0); // Dribble offset vector

            if (moveForward) playerVelocity.z -= currentSpeed;
            if (moveBackward) playerVelocity.z += currentSpeed;
            if (moveLeft) {
                playerVelocity.x -= currentSpeed;
                offsetVector.x -= dribbleOffset; // Left Dribble offset
            }
            if (moveRight) {
                playerVelocity.x += currentSpeed;
                offsetVector.x += dribbleOffset; // Right Dribble offset
            }

            // Apply movement to the camera
            camera.translateX(playerVelocity.x);
            camera.translateZ(playerVelocity.z);

            // 3. Ball Tethering (Dribbling)
            if (!isShooting) {
                // Ball position is locked to the player's position + the offset vector
                ballBody.position.set(
                    camera.position.x + offsetVector.x,
                    camera.position.y - 0.5 + Math.sin(Date.now() / 150) * 0.1, // Visual bounce effect
                    camera.position.z + offsetVector.z
                );
                ballBody.quaternion.copy(camera.quaternion); // Keep ball oriented with player
            } 
            
            // 4. Reset Ball Logic (if the ball is shot and comes to rest)
            if (isShooting && ballBody.position.y < 0.1 && ballBody.position.y > -1) {
                // If ball is on the ground, allow player to "pick up" by running close
                let dist = camera.position.distanceTo(ballMesh.position);
                if (dist < 1.0) {
                    resetBall();
                }
            }


            // 5. Sync Three.js Mesh with Cannon.js Body
            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);


            // 6. Render the scene
            renderer.render(scene, camera);
        }

        window.onload = function () {
            init();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
